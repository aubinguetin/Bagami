# Bagami Final Test Cases & Verification Guide

This document outlines the detailed test scenarios for verifying the critical functionalities of the Bagami platform, specifically focusing on the recently implemented Real-time Notification system, Wallet & Payment security hardening, and Social Login stability.

Use this guide for User Acceptance Testing (UAT) and final client verification.

---

## 1. ðŸ”” Notifications System (Real-time Migration)
**Objective:** Verify that notifications appear instantly without page refresh or polling lag.

### Test Case 1.1: Real-time Notification Arrival
*   **Prerequisites:** Two user accounts (User A and User B). User A and User B are logged in on different browsers/devices.
*   **Setup:** User A is on the Notifications page (`/notifications`).
*   **Action:**
    1.  User B sends a message to User A OR triggers a delivery alert match for User A.
    2.  Alternatively, Admin sends a global notification via Backoffice to User A.
*   **Expected Result:**
    *   User A's Notification page updates **instantly** (within 1-2 seconds).
    *   The Unread Count badge in the bottom navigation (or header) increments immediately.
    *   **No page refresh** is required.
    *   Network tab shows a WebSocket/Firebase signal received (not a periodic XHR poll).

### Test Case 1.2: Mark as Read in Real-time
*   **Action:** User A clicks "Mark all as read" or clicks a specific notification.
*   **Expected Result:**
    *   The unread styling (bg-blue-50) disappears immediately.
    *   The Unread Count badge decrements or disappears immediately.

---

## 2. ðŸ’° Wallet & Payment System (Security Hardened)
**Objective:** Verify that wallet balances are accurate, secure against race conditions, and proof against double-charging.

### Test Case 2.1: Atomic Balance Deduction (Race Condition Test)
*   **Description:** Verify that rapid-fire clicks do not deduct money multiple times incorrectly or cause negative balance errors in a way that bypasses logic.
*   **Action:**
    1.  User has a balance of 5000 FCFA.
    2.  User attempts to pay for a Delivery requiring 3000 FCFA.
    3.  User clicks the "Confirm Payment" button **rapidly multiple times** (simulate double-click or network lag).
*   **Expected Result:**
    *   Only **ONE** transaction is recorded.
    *   Balance becomes 2000 FCFA.
    *   System gracefully handles concurrent requests via Database Locking (`prisma.$transaction`).

### Test Case 2.2: Idempotency Check (Double Charge Prevention)
*   **Description:** Verify that retrying the same payment request (e.g., refreshing the page during processing) does not charge the user twice.
*   **Action:**
    1.  Initiate a payment for Delivery X (Reference ID: `DELIVERY-X`).
    2.  Simulate a network timeout or refresh the page right after the request is sent but before the UI updates.
    3.  Check the "Transactions" list.
*   **Expected Result:**
    *   Only **ONE** "Debit" transaction exists for Delivery X.
    *   If the user tries to pay again for the *same* delivery, the system detects the existing completed transaction and returns "Success" without deducting funds again.

### Test Case 2.3: Insufficient Balance Blocking
*   **Action:** User has 1000 FCFA. Delivery costs 5000 FCFA. User tries to pay.
*   **Expected Result:**
    *   Payment is **blocked** immediately.
    *   "Insufficient Balance" modal appears.
    *   User is redirected/prompted to perform Direct Payment or Top-up.

### Test Case 2.4: Direct Payment Flow (Security Fix Verification)
*   **Description:** Verify that users cannot manipulate URL parameters to fake a direct payment.
*   **Action:**
    1.  User goes to Direct Payment page.
    2.  User **manually edits** the URL parameters to add `&success=true` or similar attempts to bypass.
    3.  User returns to the Payment Summary page.
*   **Expected Result:**
    *   The system ignores URL tampering.
    *   Payment is NOT marked as completed unless the secure `sessionStorage` token (generated by the backend/internal logic) is present and valid.

---

## 3. ðŸŒ Social Login & Payment Integration (Bug Fix)
**Objective:** Verify that users logging in via Google/Facebook have fully functional wallets and can perform payments.

### Test Case 3.1: Google/Facebook User Creation & Wallet Init
*   **Action:**
    1.  User clicks "Login with Google" or "Login with Facebook".
    2.  New account is created automatically.
*   **Verification:**
    *   Check Database: User ID should be a CUID (standard system ID), NOT the Google/Facebook long numeric ID.
    *   Go to "Wallet" page: A wallet should be automatically created with 0 FCFA balance. (No 500/404 errors).

### Test Case 3.2: Social User Payment
*   **Prerequisites:** A Google/Facebook user with sufficient balance (or simulate via database/admin top-up).
*   **Action:**
    1.  User attempts to pay for a delivery.
    2.  Confirm payment.
*   **Expected Result:**
    *   Payment succeeds.
    *   Transaction history loads correctly.
    *   **Reason:** The system now correctly links the social session to the internal Database User ID, ensuring the Wallet lookup succeeds.

---

## 4. ðŸ“ Transaction History
**Objective:** Verify accurate logging of all financial movements.

### Test Case 4.1: History Logging
*   **Action:** Perform a Credit (Top-up) and a Debit (Payment).
*   **Expected Result:**
    *   Transaction list shows both entries.
    *   "Credit" is positive (Green), "Debit" is negative (Red).
    *   Details include: Date, Amount, Currency, and Description (e.g., "Payment for Delivery: [Title]").

### Test Case 4.2: Admin View (Backoffice)
*   **Action:** Login as Admin -> View User -> Transactions.
*   **Expected Result:** Admin can see the exact same transaction history for the user, ensuring financial transparency.
